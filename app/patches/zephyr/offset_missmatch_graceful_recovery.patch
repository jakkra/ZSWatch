diff --git a/subsys/mgmt/mcumgr/grp/fs_mgmt/src/fs_mgmt.c b/subsys/mgmt/mcumgr/grp/fs_mgmt/src/fs_mgmt.c
index 44926c7eff0..33d3dd7c571 100644
--- a/subsys/mgmt/mcumgr/grp/fs_mgmt/src/fs_mgmt.c
+++ b/subsys/mgmt/mcumgr/grp/fs_mgmt/src/fs_mgmt.c
@@ -143,6 +143,8 @@ static void file_close_work_handler(struct k_work *work)
 		return;
 	}
 
+	LOG_WRN("Auto-closing idle file: %s (state=%d, off=%zu)",
+		fs_mgmt_ctxt.path, fs_mgmt_ctxt.state, fs_mgmt_ctxt.off);
 	(void)fs_mgmt_cleanup();
 
 	k_sem_give(&fs_mgmt_ctxt.lock_sem);
@@ -510,16 +512,19 @@ static int fs_mgmt_file_upload(struct smp_streamer *ctxt)
 
 	/* Verify that the data offset matches the expected offset (i.e. current size of file) */
 	if (off > 0 && off != fs_mgmt_ctxt.off) {
-		/* Offset mismatch, send file length, client needs to handle this */
-		ok = smp_add_cmd_err(zse, MGMT_GROUP_ID_FS, FS_MGMT_ERR_FILE_OFFSET_NOT_VALID);
-		ok = zcbor_tstr_put_lit(zse, "len")		&&
-		     zcbor_uint64_put(zse, fs_mgmt_ctxt.off);
-
-		/* Because the client would most likely decide to abort and transfer and start
-		 * again, clean everything up and release the file handle so it can be used
-		 * elsewhere (if needed).
+		/* Offset mismatch â€” likely caused by BLE packet loss (write-without-response).
+		 * Instead of aborting, respond with the server's current offset so the
+		 * mcumgr client library can resend from the correct position.
 		 */
-		(void)fs_mgmt_cleanup();
+		if (off > fs_mgmt_ctxt.off) {
+			LOG_ERR("Upload offset ahead (recovering): client=%llu expected=%zu file=%s",
+				off, fs_mgmt_ctxt.off, fs_mgmt_ctxt.path);
+		} else {
+			LOG_ERR("Upload offset behind (skipping): client=%llu expected=%zu file=%s",
+				off, fs_mgmt_ctxt.off, fs_mgmt_ctxt.path);
+		}
+
+		ok = fs_mgmt_file_rsp(zse, MGMT_ERR_EOK, fs_mgmt_ctxt.off);
 		goto end;
 	}
 
